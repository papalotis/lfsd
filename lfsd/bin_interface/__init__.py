import struct
from pathlib import Path
from typing import Any

import numpy as np

from lfsd.common_types import FloatArray


def parse_car_info(path: Path) -> dict[str, Any]:
    # Generated by Chat GPT. Only some parts have been verified to be correct.
    data = path.read_bytes()
    # Parse fixed-size fields
    identifier = data[0:6].decode()
    version = data[7]
    if version > 1:
        raise ValueError("Unsupported version")
    short_car_name = data[8:11].decode()
    passengers = data[12]
    body_matrix = struct.unpack("9f", data[16:52])
    ref_point_pos_world = struct.unpack("3i", data[52:64])
    cog_world = struct.unpack("3i", data[64:76])
    cog_local = struct.unpack("3f", data[76:88])
    fuel_tank_pos_local = struct.unpack("3f", data[88:100])
    # Skipping zeros
    aero_blocks = [
        struct.unpack("5f", data[128 + i * 20 : 148 + i * 20]) for i in range(4)
    ]
    moi_matrix = struct.unpack("9f", data[208:244])
    engine_info = struct.unpack("4f", data[256:272])
    car_specs = struct.unpack("4f", data[272:288])
    transmission_info = struct.unpack("2b", data[288:290]) + struct.unpack(
        "2f", data[292:300]
    )
    gears = struct.unpack("8f", data[304:336])
    final_drive_and_steering = struct.unpack("4f", data[336:352])
    # Skipping zeros

    # Define wheel names for keys
    wheel_names = [
        "rear_left_wheel",
        "rear_right_wheel",
        "front_left_wheel",
        "front_right_wheel",
    ]

    wheels_info = {}
    for i, name in enumerate(
        wheel_names
    ):  # Assuming 4 wheels: Rear Left, Rear Right, Front Left, Front Right
        wheel_offset = 384 + i * 128
        wheel_data = data[wheel_offset : wheel_offset + 128]
        tyre_info = struct.unpack("4b", wheel_data[0:4])
        pressure_and_temps = struct.unpack("2f", wheel_data[4:12])
        contact_and_mass = struct.unpack("4f", wheel_data[16:32])
        tyre_dimensions = struct.unpack("4f", wheel_data[32:48])
        suspension_info = struct.unpack("4f", wheel_data[48:64])
        alignment_info = struct.unpack("4f", wheel_data[64:80])
        suspension_deflection = struct.unpack("4f", wheel_data[80:96])
        tyre_deflection = struct.unpack("4f", wheel_data[96:112])
        wheels_info[name] = (
            tyre_info,
            pressure_and_temps,
            contact_and_mass,
            tyre_dimensions,
            suspension_info,
            alignment_info,
            suspension_deflection,
            tyre_deflection,
        )

    return {
        "identifier": identifier,
        "version": version,
        "short_car_name": short_car_name,
        "passengers": passengers,
        "body_matrix": body_matrix,
        "ref_point_pos_world": ref_point_pos_world,
        "cog_world": cog_world,
        "cog_local": cog_local,
        "fuel_tank_pos_local": fuel_tank_pos_local,
        "aero_blocks": aero_blocks,
        "moi_matrix": moi_matrix,
        "engine_info": engine_info,
        "car_specs": car_specs,
        "transmission_info": transmission_info,
        "gears": gears,
        "final_drive_and_steering": final_drive_and_steering,
        "wheels": wheels_info,
    }


class BinInterface:
    def __init__(self, lfs_path: Path | str) -> None:
        self.lfs_path = Path(lfs_path)

    def load_bin_file_for_car(self, car_name: str) -> dict[str, Any]:
        path = self.lfs_path / "data" / "raf" / f"{car_name}_info.bin"
        if not path.exists():
            raise FileNotFoundError(
                f'Could not .bin file for {car_name}. Enter the garage view for the car you want to get the bin info and press the "O" key to generate it.'
            )

        return parse_car_info(path)

    def wheel_offsets_xy(self, car_name: str) -> FloatArray:
        car_info = self.load_bin_file_for_car(car_name)

        return_value: list[tuple[float, float]] = []
        for wheel in car_info["wheels"]:
            x, y, _, _ = wheel[2]
            return_value.append((x, y))

        return np.array(return_value)
